[1과목 : 데이터 모델링의 이해]

1. 분산 데이터베이스
  * 장점 
    ㆍ병렬식 처리를 수행하기 때문에 빠르게 응답 가능
    ㆍ시스템 용량 확장이 쉬움
    ㆍ장애 시에 다른 데이터베이스가 서비스하게 해 신뢰성과 가용성 상승
   * 단점
    ㆍ여러 개의 데이터베이스 존재 => 설계 및 관리와 통제가 어려움
    ㆍ보안 통제가 어렵고, 비용이 상승
    ㆍ데이터 무결성 관리가 어려움

  * 투명성
    ㆍ분할 투명성
      - 하나의 엔터티가 여러 개의 분산 데이터베이스에 저장되어 있지만 사용자는 그 내용을 알 필요 없다
    ㆍ중복 투명성
      - 여러 데이터베이스가 중복되어서 데이터가 저장되는 것
    ㆍ병행 투명성
      - 여러 개의 분산 데이터베이스에서 동시에 트랜잭션이 실행되는 것
    ㆍ지역 사항 투명성
      - 지역 DBMS와 물리적 데이터베이스 사이의 사상이 보장됨에 따라 각 지역 시스템 이름과 무관한 이름 사용 가능


2. 데이터 모델링 관점
  ㆍ 데이터 관점
    - 내용 : 업무에서 사용하는 데이터
    - 활동 : 구조분석

  ㆍ 프로세스 관점
    - 내용 : 하는 일
    - 활동 : 업무 시나리오 분석

  ㆍ 데이터와 프로세스의 상관 관점
    - 내용 : 업무와 데이터간의 관계, 
    - 활동 : CRUD 메트릭스

3. Hash Join
  ㆍ 선행 테이블의 행 수를 더 작게 설정

4. 속성의 종류
  * 분해여부에 따른 속성 종류
    ㆍ 단일 속성
      - 하나의 의미로 구성된 것
      - ex) 회원 ID, 이름 등

    ㆍ 복합 속성
      - 여러 개의 의미가 있는 것
      - ex) 주소 -> 시, 군, 동 등으로 분해 가능

    ㆍ 다중값 속성
      - 속성에 여러 개의 값을 가질 수 있는 것
      - 엔터티로 분해된다.
      - ex) 상품리스트 

  * 특성에 따른 속성 종류
    ㆍ 기본 속성
      - 비즈니스 프로세스에서 도출되는 본래의 속성
      - 가장 일반적인 것으로, 다른 속성에서 계산하거나 영향을 받은 것을 제외한 모든 속성
      - ex) 회원ID, 이름, 계좌번호, 주문 일자 등

    ㆍ 설계 속성
      - 데이터 모델링 과정에서 발생되는 속성
      - 유일한 값을 부여
      - ex) 상품코드, 지점코드 등

    ㆍ 파생 속성
      - 다른 속성에 의해서 만들어지는 속성
      - ex) 합계, 평균 등

5. 3층 스키마
  * 외부 스키마
    ㆍ 사용자 관점 또는 사용자 뷰(view)를 표현
    ㆍ 업무상 관련이 있는 데이터만 접근(권한 설정)한다
    ㆍ 관련된 데이터의 일부만 표시(view)한다

  * 개념 스키마
    - 사용자 전체 집단의 데이터베이스 구조를 표현
    - 전체 데이터베이스 내의 모든 데이터에 관한 규칙과 의미를 묘사

  * 내부 스키마
    ㆍ 데이터베이스의 물리적 저장 구조
    ㆍ 데이터 저장 구조, 레코드의 구조, 필드의 정의, 색인과 해시를 생성
    ㆍ 운영체제와 하드웨어에 종속적


6. 반정규화 => 데이터를 중복시켜 데이터베이스 성능 향상
  * 데이터를 조회할 때 디스크 입출력 량이 많아서 성능이 저하될 때
  * 여러 개의 테이블 조인으로 인한 성능저하가 예상될 때
  * 칼럼의 합계 및 평균 등을 계산하여 읽을 때 성능이 저하될 것이 예상될 때
  
  * 반정규화 절차
    ㆍ대상 확인
      - 조인에 사용되는 테이블 및 대량의 데이터 처리, 통계 처리 등을 확인
    ㆍ다른 방법 결정
      - 인덱스 조정을 통한 튜닝 실시
      - 애플리케이션에 배열 처리를 수행
      - 뷰(view) 혹은 클러스터링 인덱스 기법을 적용
        cf) 클러스터링 : 인덱스 정보를 저장할 때 물리적으로 정렬해서 저장하는 방법 => 조회 시에 인접 블록을 연속적으로 읽기 때문에 성능 향상
    ㆍ반정규화 실행
      - 테이블, 속성, 관계 등에 대한 반정규화를 수행

  * 반정규화 기법
    ㆍ테이블 추가 및 계산된 칼럼 추가
      - ex) 일별 주문 테이블을 분석하는 월별 매출 집계 테이블의 성능향상을 위해 사전에 월별 매출과 평균 등을 계산하여 월별 매출 집계 테이블을 생성 한다
    ㆍ테이블 분할
      - 대표적으로 파티션
      - 파티션의 장점
        ∘데이터 조회 시에 액세스 범위가 줄어들기 때문에 성능이 향상
        ∘데이터가 분할되어 있기 때문에 I/O(Input/Output)의 성능이 향상
        ∘각 파티션을 독립적으로 백업 및 복구가 가능
    ㆍ테이블 병합
      - 두 개의 엔터티가 1:1 관계인 경우, 하나의 테이블 만 생성하도록 한다
      - 두 개의 엔터티가 1:N 관계인 경우, 하나의 테이블 만 생성하도록 한다
         => 많은 양의 데이터 중복 발생
      - Super Type-Sub Type관계인 경우, 하나의 테이블로 통합 한다

7. Super Type-Sub Type(슈퍼타입 및 서브타입) 변환 방법
  => 애플리케이션이 테이블을 어떻게 사용하는지가 가장 고려되어야 함.
  * OneToOne Type
    - 슈퍼타입, 서브타입 개별 테이블로 도출
    - 테이블 수가 많아 조인이 많이 발생 => 관리 어렵
  * Plus Type
    - 슈퍼타입과 서브타입 테이블로 도출
    - 조인이 발생하고 관리가 어렵
  * Single Type
    - 슈퍼타입과 서브타입을 하나의 테이블로 도출
    - 서브타입의 테이블들을 항상 같이, 동시에 조회
    - 조인 성능이 좋고 관리가 편하나, 입출력 성능이 안좋음

8. 카디널리티 = 선택도 * 전체 레코드(행, row) 수
    : 두 개의 엔터티에서 관계에 참여하는 수, 1:1, 1:N, M:N과 같이 관계의 기수성을 나타내는 것

9. 정규화
  ㆍ함수적 종속성에 따라 데이터의 일관성, 유연성 확보 및 중복을 없애기 위한 데이터 분해과정
  ㆍ정보 이상현상(삽입ㆍ삭제ㆍ수정 이상현상)이 발생하지 않도록 한다
  ㆍ정보의 손실을 막는다
  ㆍ정보의 보안 목적? => [X], 뷰(view)로 해결

  * 제1정규화
    - 속성의 원자성 확보
    - 기본키를 설정

  * 제2정규화
    - 기본키가 2개 이상의 속성으로 이루어진 경우, 부분 함수 종속성을 제거(분해)
  
  * 제3정규화
    - 기본키를 제외한 칼럼 간에 종속성 제거(이행 함수 종속성 제거)
  
  * BNCF
    - 기본키를 제외하고 후보키가 있을 경우, 후보키가 기본키를 종속시키면 분해


10. 데이터베이스 파티션 기법
  * Range Partition
    ㆍ 데이터 값의 범위를 기준으로 파티션 수행
    ㆍ 날짜 및 숫자처럼 연속된 값을 기준으로 만듬

  * List Partition
    ㆍ 특정 값을 지정해서 파티션 수행
    ㆍ 파티셔닝 할 항목을 관리자가 직접 지정하는 방법
    ㆍ 데이터 보관 주기에 따라 쉽게 데이터를 삭제할 수 없다

  * Hash Partition
    ㆍ 해시 함수를 적용하여 파티션 수행

  * Composite Partition
    ㆍ 범위와 해시를 복합적으로 사용해 파티션 수행


11. 엔터티 간의 관계
  * 식별 관계
  * 비식별 관계
    ㆍ 약한 연결 관계 표현
    ㆍ 자식이 일반 속성에 표함 됨
    ㆍ 엔터티 간의 관계를 점선으로 표현
    ㆍ 부모 쪽의 관계 참여가 선택적

12. 이상 현상
   : 정규화를 하지 않아 발생하는 문제점  ex) 삽입 이상, 갱신 이상, 삭제 이상 등


13. 엔터티의 종류
  * 물리적 형태(유형과 무형)에 따른 엔터티 종류
    ㆍ유형 엔터티
      - 업무에서 도출되며 지속적으로 사용되는 엔터티
      - 물리적 형태가 있다
      - ex) 고객, 강사, 사원 등
    ㆍ개념 엔터티
      - 개념적으로 사용되는 엔터티
      - 물리적 형태가 없다
      - ex) 거래소 종목, 코스닥 종목, 생명보험 상품
     ㆍ사건 엔터티
      - 비즈니스 프로세스를 실행하면서 생성되는 엔터티
      - ex) 주문, 체결, 취소주문, 수수료 청구 등
  * 발생 시점에 따른 엔터티 종류
    ㆍ기본 엔터티(키 엔터티)
      - 다른 엔터티로부터 영향을 받지 않고 독립적으로 생성되는 엔터티
      - 발생 시점에 따라서 엔터티를 분류할 때 독립적을 생성됨
      - ex) 고객, 상품, 부서 등
    ㆍ중심 엔터티
      - 기본 엔터티와 행위 엔터티 간의 중간에 있는 것
      - 기본 엔터티로부터 발생되고 행위 엔터티를 생성하는 것
      - ex) 계좌, 주문, 취소, 체결 등
    ㆍ행위 엔터티
      - 2개 이상의 엔터티로부터 발생된다
      - ex) 주문 이력, 체결 이력 등

  * 교차 엔터티(AssociationㆍRelationshipㆍIntersection Entity)
    : M:N 관계를 해소하려는 목적으로 인위적으로 만들어진 엔터티


14. 데이터베이스 모델링 단계
  * 개념적 모델링
    - 추상화 수준이 높고 업무에 대한 엔터티를 도출하고 관계를 정의하는 단계
    - 사용자 관점에서 데이터 요구사항을 식별하는 단계
 
  * 논리적 모델링
    - 개념적 모델링 이후에 구체적인 업무 중심의 모델링
    - M:N 관계형 식별자 확정, 정규화, 무결성 정의 등을 수행하는 단계
    - 재사용성이 높은 단계

  * 물리적 모델링
    - 성능, 데이터 저장 방법 등을 고려하는 모델링
    - 개념적, 논리적, 물리적 단계로 진행될수록 상세화 된다

14. 엔터티 인스턴스, 속성, 속성 값의 관계
  ㆍ한 개의 엔터티는 두 개 이상의 속성과 두 개 이상의 인스턴스를 가진다
  ㆍ한 개의 속성은 한 개의 속성값을 가진다
  ㆍ속성명은 업무에서 사용하는 명칭을 사용
  ㆍ속성명은 데이터 모델에서 유일하게 사용해야 한다
  ㆍ엔터티는 유일한 식별자가 있어야 한다  ex) 회원ID, 계좌번호
  ㆍ엔터티는 다른 엔터티와 최소 한 개 이상의 관계를 가져야 한다.
  ㆍ엔터티는 업무에서 관리되어야 하는 집합이다  ex) 고객, 계좌


15. 도메인
  ㆍ각 속성이 가질 수 있도록 허용된 값들의 집합
  ㆍ도메인별로 데이터 타입과 길이를 지정
  ㆍ속성명과 도메인명이 반드시 동일할 필요는 없다
  ㆍ릴레이션에서 모든 속성의 도메인은 원자적(Atomic)
  ㆍ공통으로 발생하는 명사는 하나의 도메인으로 생성
  ㆍ속성에 값을 입력할 때 CHECK 기능을 사용해서 입력값을 검사한다
  ㆍ속성에 대해서 NOT NULL 제약사항을 설정하여 NULL 값을 허용하지 않는다


16. 식별자
  * 대표성 여부에 따른
    ㆍ주식별자
      - 속성의 수에 대한 유일성과 최소성을 만족하면서 엔터티를 대표하는 식별자
      - 엔터티 내에 모든 인스턴스가 유일하게 구분되어야 한다
      - 다른 엔터티와 참조관계로 연결될 수 있다
      - 주식별자의 값은 자주 변하지 않는 것이어야 한다
      - 주식별자의 값은 not null
    ㆍ보조 식별자
      - 유일성과 최소성은 만족하나 대표성 X
  
  * 생성여부에 따른
    ㆍ내부 식별자
      - 엔터티 내부에서 스스로 생성
      - ex) 부서코드, 주문번호, 종목코드 등
    ㆍ외부 식별자
      - 다른 엔터티와의 관계로 인해 생성
      - ex)계좌 엔터티의 회원ID

  * 속성 수에 따른
    ㆍ단일 식별자
      - 하나의 속성  ex) 고객 엔터티의 회원ID
    ㆍ복합 식별자
      - 두 개 이상의 속성

  * 대체 여부에 따른
    ㆍ본질 식별자
      - 비즈니스 프로세스(업무)에 의해 만들어짐
    ㆍ인조 식별자
      - 인위적으로 만들어짐
      - 후보 식별자 중, 주식별자로 선정할 것이 없거나 너무 많은 칼럼으로 되어 있을 때 사용
      - 순서번호를 사용함


17. 인덱스
  ㆍ데이터베이스에서 인덱스를 생성하면 인덱스 키는 자동정렬 되어 있다
  ㆍ특정 테이블에 인덱스를 사용해서 접근하면 원하는 값을 빠르게 탐색할 수 있다
  ㆍ기본키로 지정된 칼럼은 자동으로 인덱스가 생성된다
  ㆍ많은 양의 데이터를 인덱스를 사용해서 스캔하는 경우에 오히려 성능이 떨어질 수 있다


18. Super Type-Sub Type
  * 베타적 관계 모델링
    ㆍ한순간에 하나만 될 수 있다
  * 포괄적 관계 모델링


19. ERD(Enitity Relationship Diagram) 작성 순서
    엔터티를 그린다
    -> 엔터티를 적절하게 배치한다
    -> 엔터티 간에 관계를 설정한다
    -> 관계명을 기술한다
    -> 관계의 참여도를 기술한다
    -> 관계의 필수 여부를 기술한다


21. 성능 데이터 모델링에서 고려해야 할 사항
  ㆍ정규화를 수행하여 데이터베이스 모델의 유연성 확보
  ㆍ데이터베이스의 전체 용량, 월간, 연간 증감율을 예측
  ㆍ애플리케이션의 트랜잭션 유형(CRUD : Create Read Update Delete)을 파악
  ㆍ합계 및 정산 등을 수행하는 반정규화를 수행
  ㆍ기본키와 외래키, 슈퍼타입과 서브타입 등을 조정
  ㆍ성능관점에서 데이터 모델을 검증하고 확인


22. 속성
  * 기본키 속성
    ㆍ 엔터티를 식별할 수 있는 속성, 최소성(Not Null), 유일성(중복X) 만족해야 한다
  * 외래키 속성
    ㆍ다른 엔터티의 관계에 포함되는 속성
    ㆍ일반 속성
      - 다른 엔터티와의 관계에 포함되지 않는 속성
  * 기본 속성
    ㆍ비즈니스 프로세스에서 도출되는 본래의 속성
    ㆍex) 회원ID, 이름, 계좌번호, 주문일자 등
  * 설계 속성
    ㆍ데이터 모델링 과정에서 발생되는 속성
    ㆍ유일한 값을 부여한다
    ㆍex) 상품코드, 지점코드 등
  * 파생 속성
    ㆍ다른 속성에 의해서 만들어지는 속성
    ㆍex) 합계, 평균 등


23. 식별자 관계
  * 식별자 관계
    ㆍ목적 : 강한 연결 관계
    ㆍ기본키 : 부모 릴레이션의 기본키가 자식 릴레이션의 기본키로 사용됨
    ㆍ표기법 : 실선 표현
  * 비식별자 관계
    ㆍ목적 : 약한 연결 관계
    ㆍ기본키 : 부모 릴레이션의 기본키가 자식 릴레이션의 일반 속성으로 사용됨
    ㆍ표기법 : 점선 표현


24. 성능을 고려한 데이터베이스 모델링 단계
  정규화를 수행해서 데이터 모델의 독립성 향상
  -> 필요에 따라 트랜잭션 유형, 반정규화 등을 수행
  -> 성능관점에서 데이터 모델을 검증